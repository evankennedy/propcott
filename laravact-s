#!/usr/bin/env php
<?php

class SharedData extends Stackable {
    //private $name;
    public function __construct($_name = '') {
        
    }
    public function run(){
        
    }
}

function formatBytes($size, $precision = 2, $useIEC = true)
{
	$suffixes = $useIEC ? array('', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB') : array('', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB');  
	$factor = $useIEC ? 1024 : 1000;
	$base = log($size, $factor);

	return round(pow($factor, $base - floor($base)), $precision) . $suffixes[floor($base)];
}

require __DIR__.'/laravact/src/Server.php';
$shared = new SharedData();
$pool = array();
$workers = 2;
for($i = 0; $i < $workers; $i++) {
	$pool[] = new Laravact\Server($shared, 'localhost', 5501 + $i, $i);
	end($pool)->start();
}

require __DIR__.'/bootstrap/autoload.php';

class Server2 extends \Evenement\EventEmitter implements \React\Http\ServerInterface
{
    private $io;
    public function __construct(\React\Socket\ServerInterface $io)
    {
        $this->io = $io;
        $this->io->on('connection', function (\React\Socket\ConnectionInterface $conn) {
            // TODO: http 1.1 keep-alive
            // TODO: chunked transfer encoding (also for outgoing data)
            // TODO: multipart parsing
            $parser = new \React\Http\RequestHeaderParser();
            $parser->on('headers', function (\React\Http\Request $request, $bodyBuffer) use ($conn, $parser) {
                // attach remote ip to the request as metadata
                $request->remoteAddress = $conn->getRemoteAddress();
                $this->handleRequest($conn, $request, $bodyBuffer);
                $conn->removeListener('data', array($parser, 'feed'));
                $conn->on('end', function () use ($request) {
                    $request->emit('end');
                });
                $conn->on('data', function ($data) use ($request) {
                    $request->emit('data', array($data));
                });
                $request->on('pause', function () use ($conn) {
                    $conn->emit('pause');
                });
                $request->on('resume', function () use ($conn) {
                    $conn->emit('resume');
                });
            });
            $conn->on('data', array($parser, 'feed'));
        });
    }
    public function handleRequest(\React\Socket\ConnectionInterface $conn, \React\Http\Request $request, $bodyBuffer)
    {
        $response = new \React\Http\Response($conn);
        $response->on('close', array($request, 'close'));
        if (!$this->listeners('request')) {
            $response->end();
            return;
        }
                	
        $this->emit('request', array($request, $response));
        $request->emit('data', array($bodyBuffer));
    }
}

$loop = \React\EventLoop\Factory::create();
$socket = new \React\Socket\Server($loop);
$http = new \React\Http\Server($socket, $loop);
$http->on('request', function ($request, $response) {
	print_r($_FILES);
	$response->writeHead(200, array('Content-Type' => 'text/html'));
	$response->end('<form method="POST"><input name="textr" /><input type="file" name="filer" /><input type="submit" /></form>');
});
$socket->listen(5500, '127.0.0.1');

/*$loop->addPeriodicTimer(3, function() use ($shared) {
	printf('manager : %s %s' . PHP_EOL, formatBytes(memory_get_usage()), formatBytes(memory_get_peak_usage()));
	foreach($shared as $num => $d) {
		printf('server %d: %s %s' . PHP_EOL, $num, formatBytes($d[1]), formatBytes($d[2]));
	}
});*/

$loop->run();
